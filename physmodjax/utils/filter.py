# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/utils/filter.ipynb.

# %% auto 0
__all__ = ['NonLinearStringCellAvanzini', 'NonLinearString']

# %% ../../nbs/utils/filter.ipynb 2
from jax.typing import ArrayLike
from flax import linen as nn
import jax.numpy as jnp
import jax
import numpy as np
from physmodjax.utils.ftm import (
    StringParameters,
    string_eigenvalues_sqrt,
    string_eigenfunctions,
    inverse_STL,
    forward_STL,
    eigenvalues_from_pde,
    tf_initial_conditions_discrete,
)
from ..solver.generator import create_pluck_modal
from dataclasses import dataclass, asdict

# %% ../../nbs/utils/filter.ipynb 4
class NonLinearStringCellAvanzini(nn.Module):
    b_coeffs: ArrayLike
    a_coeffs: ArrayLike
    wavenumbers: ArrayLike
    length: float
    scalar_term: float
    b1_exc: ArrayLike
    use_nonlinear: bool

    def setup(self):
        self.a = jnp.flip(self.a_coeffs, axis=-1)
        self.Lambda = self.wavenumbers**2

    def __call__(
        self,
        carry,  # last 2 number of outputs, and 1 number of inputs ((n_modes,2), (n_modes,1))
        inputs,  # current modal input at time t (n_modes,)
    ):
        # past_x has shape (n_modes, 1) and past_y has shape (n_modes, 2)
        past_x, past_y = carry

        # multiply the past input with the nonlinearity
        y_n_1 = past_y[:, -1]  # y[n-1]

        if self.use_nonlinear:
            sum_part = jnp.sum(self.Lambda * y_n_1**2 / (self.length / 2))
            T_NL = self.scalar_term * sum_part
            F_NL = self.Lambda * T_NL * y_n_1

            # dicretise and scale the nonlinearity
            # this is a different transfer function than the one used
            # for the initial conditions
            F_NL_d = F_NL * self.b1_exc

        # concatenate to perform the matrix multiplication
        x = jnp.concatenate(
            [
                inputs[..., None],
                past_x + F_NL_d[..., None] if self.use_nonlinear else past_x,
            ],
            axis=-1,
        )

        # direct form I in parallel
        bw_sum = jnp.sum(past_y * self.a, axis=-1)  # (n_parallel,)
        fw_sum = jnp.sum(x * self.b_coeffs, axis=-1)  # (n_parallel,)

        y = fw_sum - bw_sum  # (n_parallel,)

        # we always move in a stride of 1 so we stack all the
        # values after the first one and the current value
        new_x_state = x[:, 0:1]
        new_y_state = jnp.concatenate([past_y[:, 1:], y[:, None]], axis=-1)

        return (new_x_state, new_y_state), y

# %% ../../nbs/utils/filter.ipynb 5
class NonLinearString(nn.Module):
    string_parameters: StringParameters
    sr: float
    n_max_modes: int
    use_nonlinear: bool = True

    def setup(self):

        mu = np.arange(1, self.n_max_modes + 1)
        wavenumbers = mu * np.pi / self.string_parameters.length
        dt = 1 / self.sr

        eigenvalues = eigenvalues_from_pde(
            self.string_parameters,
            wavenumbers=wavenumbers,
        )

        b, a = tf_initial_conditions_discrete(
            eigenvalues,
            dt=dt,
        )

        b = b[:, :-1] * self.sr  # unsure why we need to multiply by sr

        sigma_mu = np.real(eigenvalues)
        omega_mu = np.imag(eigenvalues)

        # eq 38 from the paper Digital Sound Synthesis of String Instruments...
        # the b1 coeficcient for the transfer function of the excitation
        b1_exc = (
            dt
            * np.exp(-sigma_mu * dt)
            * np.sin(omega_mu * dt)
            / (self.string_parameters.rho * self.string_parameters.A * omega_mu)
        )

        # scalar_term = (
        #     self.string_parameters.E
        #     * self.string_parameters.A
        #     / (self.string_parameters.length * 2)
        # )

        # self.cell = nn.scan(
        #     NonLinearStringCellAvanzini,
        #     variable_broadcast="params",
        #     split_rngs={"params": False},
        # )(
        #     b_coeffs=b,
        #     a_coeffs=a[:, 1:],
        #     scalar_term=scalar_term,
        #     wavenumbers=wavenumbers,
        #     length=self.string_parameters.length,
        #     b1_exc=b1_exc,
        #     use_nonlinear=self.use_nonlinear,
        # )

        gamma_mu = (
            wavenumbers**2
            * self.string_parameters.E
            * self.string_parameters.A
            * np.pi**2
            / self.string_parameters.length**4
        )

        self.cell = nn.scan(
            NonLinearStringCellRab,
            variable_broadcast="params",
            split_rngs={"params": False},
        )(
            b_coeffs=b,
            a_coeffs=a[:, 1:],
            gamma_mu=gamma_mu,
            b1_exc=b1_exc,
            use_nonlinear=self.use_nonlinear,
        )

    def __call__(
        self,
        x: ArrayLike,  # (n_max_modes, n) initial condition
    ) -> ArrayLike:
        """
        Compute the output of the non-linear string model.

        The input is the initial condition of the string, with shape (n, n_max_modes) as an impulse.
        The output is the displacement of the string at each time step, with shape (n, n_max_modes).

        This is so that we do not use the initial condition as parameters of the model.
        """
        # u0_bar = x[:, 0]  # initial condition

        # init_carry = (
        #     jnp.zeros((self.n_max_modes, 1), dtype=x.dtype),
        #     jnp.concatenate(
        #         [
        #             jnp.zeros((self.n_max_modes, 1), dtype=x.dtype),
        #             u0_bar[:, None],
        #         ],
        #         axis=-1,
        #     )
        # )

        init_carry = (
            jnp.zeros((self.n_max_modes, 1), dtype=x.dtype),
            jnp.concatenate(
                [
                    jnp.zeros((self.n_max_modes, 1), dtype=x.dtype),
                    jnp.zeros((self.n_max_modes, 1), dtype=x.dtype),
                ],
                axis=-1,
            ),
        )

        _, y = self.cell(
            init_carry,
            x.T,  # transpose to have shape (n, n_max_modes)
        )
        return y.T  # transpose back to have shape (n_max_modes, n)
