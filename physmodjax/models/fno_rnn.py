# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/models/fno_rnn.ipynb.

# %% auto 0
__all__ = ['FNOCell', 'FNORNN', 'BatchFNORNN']

# %% ../../nbs/models/fno_rnn.ipynb 3
import jax.numpy as jnp
from .fno import SpectralLayers1d
from flax import linen as nn
import jax

# %% ../../nbs/models/fno_rnn.ipynb 5
class FNOCell(nn.Module):
    """
    Parker's ARMA without input
    """

    hidden_channels: int
    grid_size: int
    layers: int = 4
    out_channels: int = 1
    activation: nn.Module = nn.relu

    @nn.compact
    def __call__(
        self,
        h,  # hidden state (grid_size, hidden_channels)
        x,  # input (grid_size, 1)
    ):
        down_lifting = nn.Dense(features=self.out_channels)
        spectral_layers = SpectralLayers1d(
            n_channels=self.hidden_channels,
            n_modes=self.grid_size,
            linear_conv=True,
            n_layers=self.layers,
            activation=self.activation,
        )

        h = spectral_layers(h)

        # the output is the down lifted hidden state
        # (grid_size, hidden_channels) -> (grid_size, 1)
        y = down_lifting(h)

        return h, y


class FNORNN(nn.Module):
    hidden_channels: int  # number of hidden channels
    grid_size: int  # number of grid points
    n_spectral_layers: int = 4  # number of spectral layers
    out_channels: int = 1
    length: int = (
        None  # length of the sequence. If None, the length is inferred from the input
    )
    activation: nn.Module = nn.relu

    @nn.compact
    def __call__(
        self,
        h0: jnp.ndarray,  # initial hidden state (grid_size, statevars)
        x: jnp.ndarray = None,  # input sequence (timesteps, grid_size, 1)
    ) -> jnp.ndarray:
        ScanFNOCell = nn.scan(
            FNOCell,
            variable_broadcast="params",
            split_rngs={"params": False},
            length=self.length,
        )

        scan = ScanFNOCell(
            hidden_channels=self.hidden_channels,
            grid_size=self.grid_size,
            layers=self.n_spectral_layers,
            out_channels=self.out_channels,
            activation=self.activation,
        )

        up_lifting = nn.Dense(features=self.hidden_channels)

        # We up lift the initial condition from (grid_size, 1) -> (grid_size, hidden_channels)
        h0 = up_lifting(h0)
        h, y = scan(h0, x)
        return y

# %% ../../nbs/models/fno_rnn.ipynb 7
class BatchFNORNN(nn.Module):
    hidden_channels: int  # number of hidden channels
    grid_size: int  # number of grid points
    n_spectral_layers: int = 4  # number of spectral layers
    out_channels: int = 1
    length: int = (
        None  # length of the sequence. If None, the length is inferred from the input
    )
    activation: nn.Module = nn.relu

    @nn.compact
    def __call__(
        self,
        h0: jnp.ndarray,  # initial hidden state (batch_size, grid_size, statevars)
        x: jnp.ndarray = None,  # input sequence (batch_size, timesteps, grid_size, 1)
    ) -> jnp.ndarray:
        fnornn = nn.vmap(
            FNORNN,
            in_axes=0,
            variable_axes={"params": None},
            split_rngs={"params": False},
        )
        return fnornn(
            hidden_channels=self.hidden_channels,
            grid_size=self.grid_size,
            n_spectral_layers=self.n_spectral_layers,
            out_channels=self.out_channels,
            length=self.length,
            activation=self.activation,
        )(h0, x)
