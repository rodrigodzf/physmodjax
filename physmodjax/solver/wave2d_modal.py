# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/solver/wave2d_solver_modal.ipynb.

# %% auto 0
__all__ = ['WaveSolver2DJax', 'create_2d_wave_data']

# %% ../../nbs/solver/wave2d_solver_modal.ipynb 3
import numpy as np
import jax.numpy as jnp
import jax

# %% ../../nbs/solver/wave2d_solver_modal.ipynb 4
class WaveSolver2DJax:
    def __init__(
        self,
        sampling_rate: int = 48000,  # 1/s     Temporal sampling frequency
        final_time: float = 0.02,  # s       Duration of the simulation
        rho: float = 1.2041,  # kg/m**3 Density
        n_max_modes: int = 10,  #         Number of modal expansion terms
        lx: float = 1.0,  # m       Length in x direction
        ly: float = 1.0,  # m       Length in y direction
        c0: float = 343,  # m/s     Speed of sound
        damping=1.0,  #         Damping factor
        spatial_delta=1e-3,  # m       Spatial sampling grid
    ):
        T = 1 / sampling_rate

        self.numT = round(final_time / T)
        self.t = np.linspace(0, final_time, num=self.numT, endpoint=True)  # time vector

        self.numXs = round(lx / spatial_delta)
        self.numYs = round(ly / spatial_delta)
        xs = np.linspace(0, lx, num=self.numXs, endpoint=True)  # space vector
        ys = np.linspace(0, ly, num=self.numYs, endpoint=True)  # space vector

        xv, yv = np.meshgrid(np.arange(n_max_modes), np.arange(n_max_modes))
        mux = xv.flatten() + 1
        muy = yv.flatten() + 1

        mu = np.arange(n_max_modes * n_max_modes)

        lamX = mux * np.pi / lx
        lamY = muy * np.pi / ly

        smu = 1j * c0 * np.sqrt(lamX[mu] ** 2 + lamY[mu] ** 2)

        smu = np.hstack((smu, np.conj(smu)))
        lamX = np.hstack((lamX.T, lamX.T))
        lamY = np.hstack((lamY.T, lamY.T))

        # add damping
        smu = smu - damping

        ## FTM - scaling factor
        nx = -8 * lamX**2 / (rho * smu**2) * lx * ly
        ny = -8 * lamY**2 / (rho * smu**2) * lx * ly
        nc = 8 / (rho * c0**2) * lx * ly

        nmu = nx + ny + nc

        ## FTM - Eigenfunctions
        self.K1 = lambda x, y: 4 * np.cos(lamX * x) * np.cos(lamY * y)
        self.K2 = (
            lambda x, y: 4 * lamX / (smu * rho) * np.sin(lamX * x) * np.cos(lamY * y)
        )
        self.K3 = (
            lambda x, y: 4 * lamY / (smu * rho) * np.cos(lamX * x) * np.sin(lamY * y)
        )

        self.Ka1 = (
            lambda x, y: -4 * lamX / (smu * rho) * np.sin(lamX * x) * np.cos(lamY * y)
        )
        self.Ka2 = (
            lambda x, y: -4 * lamY / (smu * rho) * np.cos(lamX * x) * np.sin(lamY * y)
        )
        self.Ka3 = lambda x, y: 4 * np.cos(lamX * x) * np.cos(lamY * y)

        K1_sp = np.zeros(
            (xs.size, ys.size, nmu.size), dtype=complex
        )  # Eigenfunctions for sound pressure
        K2_vx = np.zeros(
            (xs.size, ys.size, nmu.size), dtype=complex
        )  # Eigenfunctions for particle velocity in x-direction
        K3_vy = np.zeros(
            (xs.size, ys.size, nmu.size), dtype=complex
        )  # Eigenfunctions for particle velocity in y-direction

        for xi in range(xs.size):
            for yi in range(ys.size):
                K1_sp[xi, yi, :] = self.K1(xs[xi], ys[yi]) / nmu
                K2_vx[xi, yi, :] = self.K2(xs[xi], ys[yi]) / nmu
                K3_vy[xi, yi, :] = self.K3(xs[xi], ys[yi]) / nmu

        # Explicity copy variables
        self.lx = lx
        self.ly = ly
        self.smu = smu
        self.nmu = nmu
        self.T = T
        self.Fs = sampling_rate
        self.xs = xs
        self.ys = ys
        self.K1_sp = K1_sp
        self.K2_vx = K2_vx
        self.K3_vy = K3_vy

        self.lamX = lamX
        self.lamY = lamY

    def create_impulse(self, xe_rel, ye_rel):
        # Explicity copy variables
        lx, ly = self.lx, self.ly

        # Use a delta at exciation position on the string
        xe = xe_rel * lx
        ye = ye_rel * ly

        # impulse excitation at (xe,ye)
        fe_xy = self.Ka3(xe, ye)

        return fe_xy

    def create_random_initial(
        self,
        rng: np.random.Generator = np.random.default_rng(),
    ) -> np.ndarray:
        # Explicity copy variables
        lx, ly = self.lx, self.ly
        xs, ys = self.xs, self.ys
        smu = self.smu
        lamX, lamY = self.lamX, self.lamY

        fe_xy = np.zeros((1, smu.size))

        rx = rng.uniform(-1, 1, (smu.size, xs.size))  # Shape: (smu.size, xs.size)
        ry = rng.uniform(-1, 1, (smu.size, ys.size))  # Shape: (smu.size, ys.size)
        funX = 4 * np.cos(lamX[:, None] * xs) * rx  # Broadcasting lamX and rx
        funY = np.cos(lamY[:, None] * ys) * ry  # Broadcasting lamY and ry
        integX = np.trapz(funX, xs, axis=-1)  # Shape: (smu.size,)
        integY = np.trapz(funY, ys, axis=-1)  # Shape: (smu.size,)
        fe_xy = integX[:, np.newaxis] * integY  # Shape: (smu.size, smu.size)
        fe_xy = integX * integY

        return fe_xy

    def solve(
        self,
        u0,
        v0=None,
        parallel=True,
    ):
        ## Copy internal variables
        T = self.T
        smu = self.smu

        ## Simulation - state equation

        if parallel:
            # ybar = jnp.vander(jnp.exp(smu * T), self.t.size, increasing=True)
            # ybar = ybar * fe_x[:, None]
            # ybar = jnp.cumprod(jnp.exp(smu * T), axis=0)
            # print(ybar.shape)
            smu = jnp.repeat(smu[None, :], self.t.size - 1, axis=0)
            ybar = jax.lax.associative_scan(jnp.multiply, jnp.exp(smu * T)) * u0
            ybar = ybar.T
            ybar = jnp.concatenate((u0[..., None], ybar), axis=1)
        else:
            ybar = np.zeros((smu.size, self.t.size), dtype=complex)
            ybar[:, 0] = u0
            for k in range(1, self.t.size):  # for k = 2:length(t)
                ybar[:, k] = np.exp(smu * T) * ybar[:, k - 1]

        # project back to spatial domain
        y_sp = self.K1_sp @ ybar
        y_vx = self.K2_vx @ ybar
        y_vy = self.K3_vy @ ybar

        # y    = np.float32(np.real(y))
        ybar = jnp.real(ybar).astype(jnp.float32)
        y_sp = jnp.real(y_sp).astype(jnp.float32)
        y_vx = jnp.real(y_vx).astype(jnp.float32)
        y_vy = jnp.real(y_vy).astype(jnp.float32)

        return ybar, y_sp, y_vx, y_vy

# %% ../../nbs/solver/wave2d_solver_modal.ipynb 9
from einops import rearrange
from pathlib import Path
from fastcore.script import call_parse
from tqdm import tqdm

# %% ../../nbs/solver/wave2d_solver_modal.ipynb 10
@call_parse
def create_2d_wave_data(
    num_ics: int,  # number of initial conditions
    data_dir: str,  # directory to save the data
    W: int = 40,  # width
    dur: float = 0.01,  # time
    sample_rate: int = 48000,  # sampling rate
    simulated_modes: int = 25,  # number of modes
    seed: int = 42,  # random seed
    ic_type: str = "random",  # type of initial condition (random or impulse)
):
    # set the global precision to 64-bit
    jax.config.update("jax_enable_x64", True)

    H = W
    room_size = 1
    room_aspect_ratio = 1
    sampling_period = 1 / sample_rate
    T = round(dur / sampling_period)

    solver = WaveSolver2DJax(
        final_time=dur,
        sampling_rate=sample_rate,
        lx=room_size,
        ly=room_aspect_ratio * room_size,
        spatial_delta=room_size / W,
        n_max_modes=simulated_modes,
    )

    # approximate Gb
    total_size_bytes = num_ics * T * H * W * 3 * 4
    print("Total size in GB", total_size_bytes / 1e9)

    # make sure the data directory exists
    Path(data_dir).mkdir(parents=True, exist_ok=True)

    # seed the random number generator
    rng = np.random.default_rng(seed)
    for i in tqdm(range(1, num_ics + 1)):

        u0 = (
            solver.create_impulse(rng.uniform(), rng.uniform())
            if ic_type == "impulse"
            else solver.create_random_initial(rng)
        )

        ybar, y_sp, y_vx, y_vy = solver.solve(u0)
        run_2d = jnp.stack((y_sp, y_vx, y_vy), axis=-1)
        run_2d = rearrange(run_2d, "h w t c -> t h w c")
        jnp.save(f"{data_dir}/ic_{i:05d}.npy", run_2d)
