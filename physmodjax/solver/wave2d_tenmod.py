# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/solver/wave2d_solver_tensionmodulated.ipynb.

# %% auto 0
__all__ = ['Wave2dSolverTensionModulated']

# %% ../../nbs/solver/wave2d_solver_tensionmodulated.ipynb 8
import numpy as np
from scipy.integrate import solve_ivp, simpson

# %% ../../nbs/solver/wave2d_solver_tensionmodulated.ipynb 10
class Wave2dSolverTensionModulated:
    """
    Tension modulated wave equation solver for a rectangular stiff membrane.
    The parameters were taken from (Fletcher, 1991, p.86) and adapted to a rectangular case.
    """

    def __init__(
        self,
        sampling_rate: int = 16000,  # 1/s     Temporal sampling frequency
        final_time: float = 0.5,  # s       Duration of the simulation
        n_gridpoints_x: int = 41,  # pts/m   Spatial sampling grid
        length_x: float = 0.4,  # m       Length of x dimension
        aspect_ratio: float = 0.8,  #        Aspect ratio of the membrane, Ly/Lx
        rho: float = 1380,  # kg/m**3 Density
        h: float = 1.9e-4,  # m       Thickness
        E: int = 3.5e9,  # Pa      Young's modulus
        nu: float = 0.3,  #         Poisson's ratio
        d1: float = 8e-5,  # kg/(ms) Frequency independent loss
        d3: float = 1.4e-5,  # kg m/s  Frequency dependent loss
        Ts0: float = 2620,  # N/m       Tension per unit length
        n_max_modes: int = 36,  #         Number of modal coordinates
        use_nonlinear: bool = True,  #         Use nonlinear wave equation
    ):
        # TODO: use a ratio for the side lengths, and use the same ratio for gridpoints
        # Attributes intrinsic to the Wave Equation PDE
        self.pde_num_variables = 1
        self.pde_num_spatial_dimensions = 2
        self.pde_order_time_derivatives = 2

        # Attributes of the simulation
        self.sampling_rate = sampling_rate
        self.final_time = final_time
        self.n_gridpoints_x = n_gridpoints_x
        self.length_x = length_x
        self.aspect_ratio = aspect_ratio
        self.use_nonlinear = use_nonlinear

        # Attributes of the membrane
        self.rho = rho
        self.h = h
        self.E = E
        self.nu = nu
        self.d1 = d1
        self.d3 = d3
        self.Ts0 = Ts0

        # Use the same number of modes in x and y, this might not be a good idea for aspect ratios far from 1
        self.n_max_modes_x = int(np.floor(np.sqrt(n_max_modes)))
        self.n_max_modes_y = int(np.floor(np.sqrt(n_max_modes)))
        self.n_max_modes = self.n_max_modes_x * self.n_max_modes_y
        # if n_max_modes > n_gridpoints - 2:
        #     self.n_max_modes = n_gridpoints - 2
        #     print(f"n_max_modes too high, setting to {self.n_max_modes}")
        # else:
        #     self.n_max_modes = n_max_modes

        x = np.linspace(0, self.length_x, self.n_gridpoints_x)
        self.dx = x[1] - x[0]  # m     spatial sampling interval

        # calculate the gridpoints and length in y using the aspect ratio
        # We want dy to be as close as possible to dx
        self.length_y = self.length_x * self.aspect_ratio
        self.n_gridpoints_y = (
            int(np.floor((self.n_gridpoints_x - 1) * self.aspect_ratio)) + 1
        )

        y = np.linspace(0, self.length_y, self.n_gridpoints_y)
        self.x = x
        self.y = y

        self.grid_x, self.grid_y = np.meshgrid(x, y, indexing="ij")
        #  spatial grid
        # self.grid_x = np.m

        self.dy = y[1] - y[0]  # m     spatial sampling interval

        #  temporal grid use arange to make sure that the timestep corresponds exactly to the sampling frequency
        self.dt = 1 / self.sampling_rate  # s     temporal sampling interval
        self.timesteps = np.arange(0, self.final_time, self.dt)

        self.mu_x = np.arange(1, self.n_max_modes_x + 1)
        self.mu_y = np.arange(1, self.n_max_modes_y + 1)
        self.wavenumbers_x = self.mu_x * np.pi / self.length_x
        self.wavenumbers_y = self.mu_y * np.pi / self.length_y

        self.grid_wavenumber_x, self.grid_wavenumber_y = np.meshgrid(
            self.wavenumbers_x, self.wavenumbers_y
        )
        self.modes = np.zeros(
            (
                self.n_max_modes_x,
                self.n_max_modes_y,
                self.n_gridpoints_x,
                self.n_gridpoints_y,
            )
        )
        self.lambdas = np.zeros((self.n_max_modes_x * self.n_max_modes_y))

        for i, wx in enumerate(self.wavenumbers_x):
            for j, wy in enumerate(self.wavenumbers_y):
                self.modes[i, j, :, :] = np.sin(wx * self.grid_x) * np.sin(
                    wy * self.grid_y
                )
                self.lambdas[i * self.n_max_modes_y + j] = wx**2 + wy**2

        self.D = self.E * (self.h) ** 3 / (12 * (1 - self.nu**2))
        CNL = self.E * self.h / (1 - self.nu**2)

        beta_mu = self.D * self.lambdas**2 + self.Ts0 * self.lambdas

        # calculate the matrices
        self.Lambdadiag = np.diag(self.lambdas)
        # self.H_1 = np.diag(self.lambdas) / (self.rho * self.h)

        self.M_v = np.diag(self.d1 + self.d3 * self.lambdas) / (self.rho * self.h)

        self.M_u = np.diag(beta_mu) / (self.rho * self.h)

        # coeffficient for the nonlinear term
        self.Cb = (
            2
            * self.E
            / (self.rho * self.length_x**2 * self.length_y**2 * (1 - self.nu**2))
        )

    def print_matrices(self):
        print(f"Lambdadiag shape: {self.Lambdadiag.shape}")
        # print(f"H_1 shape: {self.H_1.shape}")
        print(f"M_v shape: {self.M_v.shape}")
        print(f"M_u shape: {self.M_u.shape}")
        return

    def print_solver_info(self):
        # Print some information
        print(f"dx: {self.dx} in meters")
        print(f"dy: {self.dy} in meters")
        print(f"dt: {self.dt} in seconds")
        print(
            f"number of points in the x direction (n_gridpoints_x): {self.n_gridpoints_x}"
        )
        print(
            f"number of points in the y direction (n_gridpoints_y): {self.n_gridpoints_y}"
        )
        print(f"time in samples (nt): {self.timesteps.shape}")
        print(f"number of modes in x direction (n_max_modes_x): {self.n_max_modes_x}")
        print(f"number of modes in y direction (n_max_modes_y): {self.n_max_modes_y}")
        print(
            f"number of modes (n_max_modes): {self.n_max_modes_x * self.n_max_modes_y}"
        )
        print(f"length in x direction (length_x): {self.length_x} in meters")
        print(f"length in y direction (length_y): {self.length_y} in meters")
        # Print the shapes of the grids and the wavenumbers
        print(f"grid_x shape: {self.grid_x.shape}")
        print(f"grid_y shape: {self.grid_y.shape}")
        print(f"wavenumbers_x shape: {self.wavenumbers_x.shape}")
        print(f"wavenumbers_y shape: {self.wavenumbers_y.shape}")
        print(f"modes shape: {self.modes.shape}")
        print(f"lambdas shape: {self.lambdas.shape}")
        return

    def to_modal(
        self, u, v, integrator: str = "simpson"  # displacement  # velocity
    ) -> tuple[np.ndarray, np.ndarray]:
        """Project the displacement and velocity to modal coordinates.
        Also flatten the arrays to be 1D.
        For now we can only consider initial conditions of zero velocity."""
        bar_u = np.zeros(self.n_max_modes)
        # bar_z2 = np.zeros(self.n_max_modes)
        bar_v = np.zeros(self.n_max_modes)

        if integrator == "simpson":
            for i in range(self.n_max_modes_x):
                for j in range(self.n_max_modes_y):
                    uu = u * self.modes[i, j, :, :]
                    bar_u[i * self.n_max_modes_y + j] = simpson(
                        [simpson(uu_y, x=self.y) for uu_y in uu], x=self.x
                    )
                    vv = v * self.modes[i, j, :, :]
                    bar_v[i * self.n_max_modes_y + j] = simpson(
                        [simpson(vv_y, x=self.y) for vv_y in vv], x=self.x
                    )
        elif integrator == "trapz":
            # This is unverified, use simpson for now
            raise NotImplementedError
            # for i in range(self.n_max_modes_x):
            #     for j in range(self.n_max_modes_y):
            #         bar_u[i * self.n_max_modes_y + j] = self.dx*self.dy*np.sum(self.modes[i, j, :, :] * u)
            #         # bar_z_dot[i * self.n_max_modes_y + j] = np.sum(
            #     self.modes[i, j, :, :] * z_dot
            # )
        else:
            raise ValueError(f"Integrator {integrator} not recognised")

        return bar_u, bar_v

    def to_displacement(
        self,
        bar_u,  # modal displacement
        bar_v,  # modal velocity
    ) -> tuple[np.ndarray, np.ndarray]:
        """Sum the modal displacements and velocities to get the displacement and velocity"""

        u = np.zeros((self.n_gridpoints_x, self.n_gridpoints_y))
        v = np.zeros((self.n_gridpoints_x, self.n_gridpoints_y))
        norm_factor = 4 / (self.length_x * self.length_y)
        for i in range(self.n_max_modes_x):
            for j in range(self.n_max_modes_y):
                u += bar_u[i * self.n_max_modes_y + j] * self.modes[i, j, :, :]
                v += bar_v[i * self.n_max_modes_y + j] * self.modes[i, j, :, :]
        u *= norm_factor
        v *= norm_factor
        return u, v

    def enforce_boundary_conditions(self, u, v):
        """Enforce dirichlet boundary conditions.
        ATTN: remember v is respect to time, not x,y
        """
        u[0, :] = 0
        u[-1, :] = 0
        u[:, 0] = 0
        u[:, -1] = 0
        v[0, :] = 0
        v[-1, :] = 0
        v[:, 0] = 0
        v[:, -1] = 0
        return u, v

    def nonlinear_membrane(
        self,
        t,  # time
        state,  # state vector
    ) -> np.ndarray:  # state at timestep t and position x (u(x, t))
        # unpack the state vector
        bar_u = state[: self.n_max_modes]  # displacement in modal coordinates
        bar_v = state[self.n_max_modes :]  # velocity in modal coordinates

        # add axis for calculation
        bar_u = bar_u[..., None]

        # calculate the $\bar{b}$ vector
        # ATTN: this b doesn't include the minus sign
        if self.use_nonlinear:
            deformation = bar_u.T @ self.Lambdadiag @ bar_u
            b = self.Cb * deformation * self.Lambdadiag @ bar_u

        # update the state vector
        bar_udot = bar_v
        bar_vdot = -self.M_v @ bar_v - self.M_u @ bar_u.squeeze()
        if self.use_nonlinear:
            bar_vdot -= b.squeeze()

        # return the state derivatives
        return np.concatenate([bar_udot, bar_vdot])

    def solve(
        self,
        u0: np.ndarray = None,  # initial displacement (default: None)
        v0: np.ndarray = None,  # initial velocity (default: None)
    ) -> tuple[np.ndarray, np.ndarray, np.ndarray]:
        """Solve the wave equation with the given initial conditions."""

        # set the initial conditions if not given
        u0 = u0 if u0 is not None else np.zeros_like(self.grid_x)
        v0 = v0 if v0 is not None else np.zeros_like(self.grid_x)

        # Enforce the simply suppported boundary conditions a tht e edges of the membrane
        u0, v0 = self.enforce_boundary_conditions(u0, v0)
        # transform the initial conditions to modal coordinates
        bar_u0, bar_v0 = self.to_modal(u0, v0)
        # solve the wave equation in modal coordinates
        sol = solve_ivp(
            fun=self.nonlinear_membrane,
            t_span=[0, self.final_time],
            y0=np.concatenate([bar_u0, bar_v0], axis=0),
            t_eval=self.timesteps,
            method="DOP853",
            rtol=1e-12,
            atol=1e-14,
        )

        # unpack the solution
        bar_u = sol.y[: self.n_max_modes]
        bar_v = sol.y[self.n_max_modes :]

        # store the modal solution
        self.bar_u = bar_u
        self.bar_v = bar_v

        # Print the shapes of the solutions
        print(f"bar_u shape: {bar_u.shape}")
        print(f"bar_v shape: {bar_v.shape}")
        # transform back to the physical domain
        # This loop is probably extremely slow but is only done once
        u = np.zeros(
            (
                len(sol.t),
                self.n_gridpoints_x,
                self.n_gridpoints_y,
            )
        )
        v = np.zeros(
            (
                len(sol.t),
                self.n_gridpoints_x,
                self.n_gridpoints_y,
            )
        )
        for i in range(len(sol.t)):
            u[i, :, :], v[i, :, :] = self.to_displacement(bar_u[:, i], bar_v[:, i])

        return (
            sol.t,
            u,
            v,
        )
