# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/solver/wave1d_solver_tensionmodulated.ipynb.

# %% auto 0
__all__ = ['nonlinear_string_func', 'Wave1dSolverTensionModulated']

# %% ../../nbs/solver/wave1d_solver_tensionmodulated.ipynb 6
import numpy as np
from scipy.integrate import solve_ivp
from ..utils.ftm import forward_STL, inverse_STL
from numba import jit, njit
from functools import partial
from einops import rearrange

# %% ../../nbs/solver/wave1d_solver_tensionmodulated.ipynb 9
@njit
def nonlinear_string_func(
    t,  # time
    state,  # state vector
    n_max_modes,  # number of modes
    use_nonlinear,  # use nonlinear wave equation
    pre,  # precalculated constant
    H,  # H matrix
    H_1,  # H_1 matrix
    M_v,  # M_v matrix
    M_y,  # M_y matrix
) -> np.ndarray:  # state at timestep t and position x (u(x, t))
    # unpack the state vector
    y = state[:n_max_modes]  # displacement in modal coordinates
    v = state[n_max_modes:]  # velocity in modal coordinates

    # add axis for calculation
    y = y.reshape(-1, 1)

    # calculate the $\bar{b}$ vector
    if use_nonlinear:
        t_1 = pre * y.T @ H @ y
        b = t_1 * H_1 @ y

    # update the state vector
    v = v
    dv_dt = -M_v @ v - M_y @ y.reshape(-1)

    if use_nonlinear:
        dv_dt -= b.reshape(-1)

    # return the state derivatives
    return np.concatenate((v, dv_dt))


class Wave1dSolverTensionModulated:
    """
    Tension modulated wave equation solver.

    This solver is based on the paper "Sound Synthesis With Tension Modulated Nonlinearities"
    and the accompanying code to the paper "Physical Modeling using Recurrent Neural Networks with Fast Convolutional Layers".
    """

    # fmt: off
    def __init__(
        self,
        sampling_rate: int = 48000,  # 1/s     Temporal sampling frequency
        final_time: float = 0.5,     # s       Duration of the simulation
        n_gridpoints: int = 101,     # pts/m   Spatial sampling grid
        length: float = 1.00,        # m       Length at rest
        A: float = 0.19634e-6,       # m**2    Cross section area
        I: float = 0.02454e-12,      # m**4    Moment of intertia
        rho: float = 7800,           # kg/m**3 Density
        E: int = 190e9,              # Pa      Young's modulus
        d1: float = 4e-3,            # kg/(ms) Frequency independent loss
        d3: float = 6e-5,            # kg m/s  Frequency dependent loss
        Ts0: float = 150,            # N       Tension
        n_max_modes: int = 50,       #         Number of modal expansion terms
        use_nonlinear: bool = True,  #         Use nonlinear wave equation
        method: str = "DOP853",      #         Integration method
        rtol: float = 1e-12,         #         Relative tolerance
        atol: float = 1e-14,         #         Absolute tolerance
    ):
    # fmt: on
        # Attributes intrinsic to the Wave Equation PDE
        self.pde_num_variables = 1
        self.pde_num_spatial_dimensions = 1
        self.pde_order_time_derivatives = 2

        # Attributes of the simulation
        self.sampling_rate = sampling_rate
        self.final_time = final_time
        self.n_gridpoints = n_gridpoints
        self.length = length
        self.use_nonlinear = use_nonlinear
        self.method = method
        self.rtol = rtol
        self.atol = atol
        
        self.A = A
        self.I = I
        self.rho = rho
        self.E = E
        self.d1 = d1
        self.d3 = d3
        self.Ts0 = Ts0

        # For Dirichlet BC, the number of possible modes is equal the the number of points in the interior of the domain
        if n_max_modes > n_gridpoints - 2:
            self.n_max_modes = n_gridpoints - 2
            print(f"n_max_modes too high, setting to {self.n_max_modes}")
        else:
            self.n_max_modes = n_max_modes

        #  spatial grid
        self.grid = np.linspace(0, self.length, self.n_gridpoints)
        self.dx = self.grid[1] - self.grid[0]  # m     spatial sampling interval

        #  temporal grid use arange to make sure that the timestep corresponds exactly to the sampling frequency
        self.dt = 1 / self.sampling_rate  # s     temporal sampling interval
        self.timesteps = np.arange(0, self.final_time, self.dt)

        self.mu = np.ascontiguousarray(np.arange(1, self.n_max_modes + 1, dtype=np.float64))
        self.wavenumbers = self.mu * np.pi / self.length

        self.modes = np.sin(np.outer(self.wavenumbers, self.grid))

        # precalculate the variables
        eta_mu = self.wavenumbers
        beta_mu = self.E * self.I * eta_mu**4 + self.Ts0 * eta_mu**2

        # calculate the matrices        
        self.H = np.ascontiguousarray(np.diag(self.mu**2))
        self.H_1 = np.ascontiguousarray(np.diag(eta_mu**2)) / (rho * A)
        self.M_v = np.ascontiguousarray(np.diag(d1 + d3 * eta_mu**2)) / (rho * A)
        self.M_y = np.ascontiguousarray(np.diag(beta_mu)) / (rho * A)
        print(f"dx: {self.dx} in meters")
        print(f"dt: {self.dt} in seconds")
        print(f"number of points (n_gridpoints): {self.grid.shape}")
        print(f"time in samples (nt): {self.timesteps.shape}")

    def solve(
        self,
        u0: np.ndarray = None,  # initial displacement (default: None)
        v0: np.ndarray = None,  # initial velocity (default: None)
    ) -> tuple[np.ndarray, np.ndarray, np.ndarray]:
        """
        Solve the wave equation with the given initial conditions.
        
        Parameters:
        ----------
        u0: np.ndarray
            Initial displacement (default: None)
        v0: np.ndarray
            Initial velocity (default: None)

        Returns:
        ----------
        t: np.ndarray
            Time steps
        u: np.ndarray
            Displacement at each time step with shape (n_timesteps, n_gridpoints)
        v: np.ndarray
            Velocity at each time step with shape (n_timesteps, n_gridpoints)
        
        """


        # set the initial conditions if not given
        u0 = u0 if u0 is not None else np.zeros_like(self.grid)
        v0 = v0 if v0 is not None else np.zeros_like(self.grid)
        # Enforce the dirichlet boundary conditions
        u0[0] = 0
        u0[-1] = 0
        v0[0] = 0
        v0[-1] = 0
        # transform the initial conditions to modal coordinates
        # This is the same  projection that we do in the modal solver for the ideal string,
        # assuming dirichlet boundary conditions (makes it a bit wasteful as we only need the interior)
        # but, this operation is only once, then we operate in modal coordinates anyway
        bar_u0 = forward_STL(self.modes, u0, self.dx)
        bar_v0 = forward_STL(self.modes, v0, self.dx)

        # solve the wave equation in modal coordinates
        sol = solve_ivp(
            fun=partial(
                nonlinear_string_func,
                n_max_modes=self.n_max_modes,
                use_nonlinear=self.use_nonlinear,
                pre=self.E * self.A * np.pi**2 / self.length**4,
                H=self.H,
                H_1=self.H_1,
                M_v=self.M_v,
                M_y=self.M_y,
            ),
            t_span=[0, self.final_time],
            y0=np.ascontiguousarray(np.concatenate([bar_u0, bar_v0], axis=0)),
            t_eval=self.timesteps,
            method=self.method,
            rtol=self.rtol,
            atol=self.atol,
        )

        # unpack the solution
        bar_u = sol.y[: self.n_max_modes]
        bar_v = sol.y[self.n_max_modes :]

        # store the modal solution
        self.bar_u = bar_u
        self.bar_v = bar_v

        # transform back to the physical domain
        u = inverse_STL(self.modes, bar_u, self.length)
        v = inverse_STL(self.modes, bar_v, self.length)

        return (
            sol.t,
            rearrange(u, "g t -> t g"),
            rearrange(v, "g t -> t g"),
        )
