"""A solver for the 1D wave equation based on the modal decomposition"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/solver/wave1d_solver_modal.ipynb.

# %% auto 0
__all__ = ['Wave1dSolverModal']

# %% ../../nbs/solver/wave1d_solver_modal.ipynb 4
import jax.numpy as jnp
import scipy.integrate as integrate
import numpy as np
import jax

# %% ../../nbs/solver/wave1d_solver_modal.ipynb 6
class Wave1dSolverModal:
    def __init__(
        self,
        sampling_rate: int = 48000,  # sampling rate, Hz (default: 48000)
        final_time: float = 1.0,  # final time of the simulation, seconds (default: 1)
        n_gridpoints: int = 101,  # number of grid points (default: 101)
        length: float = 1,  # length of the domain, meters (default: 1)
        wave_speed: float = 1,  # wave speed, meters/second (default: 1)
        boundary_conditions: str = "dirichlet_dirichlet",  # boundary conditions, either "dirichlet_dirichlet", "neumann_neumann", "dirichlet_neumann" (default: "dirichlet_dirichlet")
        n_max_modes: int = 50,  # number of eigenmodes to calculate (default: 50)
    ) -> None:
        # Attributes intrinsic to the Wave Equation PDE
        self.pde_num_variables = 1
        self.pde_num_spatial_dimensions = 1
        self.pde_order_time_derivatives = 2

        # Attributes of the simulation
        self.sampling_rate = sampling_rate
        self.final_time = final_time
        self.n_gridpoints = n_gridpoints
        self.length = length
        self.wave_speed = wave_speed
        self.boundary_conditions = boundary_conditions

        # For Dirichlet BC, the number of possible modes is equal the the number of points in the interior of the domain
        if n_max_modes > n_gridpoints - 2:
            self.n_max_modes = n_gridpoints - 2
            print(f"n_max_modes too high, setting to {self.n_max_modes}")
        else:
            self.n_max_modes = n_max_modes

        self.grid = self._create_grid()
        self.dx = self.grid[1] - self.grid[0]
        self.dt = 1 / self.sampling_rate
        self.timesteps = jnp.arange(0, self.final_time, self.dt)
        self.wavenumbers = self._calculate_mode_wavenumbers()
        self.omegas = self._calculate_mode_angular_frequencies()
        self.modes = self._calculate_mode_shapes()

        print(f"dx: {self.dx} in meters")
        print(f"dt: {self.dt} in seconds")
        print(f"number of points (n_gridpoints): {self.grid.shape}")
        print(f"time in samples (nt): {self.timesteps.shape}")

    def _create_grid(self) -> jnp.ndarray:
        return jnp.linspace(0, self.length, self.n_gridpoints)

    def _calculate_mode_wavenumbers(self) -> jnp.ndarray:
        if self.boundary_conditions == "dirichlet_dirichlet":
            wavenumbers = jnp.array(
                [jnp.pi * n / self.length for n in range(1, self.n_max_modes + 1)]
            )
        elif self.boundary_conditions == "neumann_neumann":
            wavenumbers = jnp.array(
                [jnp.pi * n / self.length for n in range(0, self.n_max_modes)]
            )
        elif self.boundary_conditions == "dirichlet_neumann":
            wavenumbers = jnp.array(
                [
                    jnp.pi * (n - 0.5) / self.length
                    for n in range(1, self.n_max_modes + 1)
                ]
            )
        else:
            raise ValueError(
                "boundary_conditions must be either 'dirichlet_dirichlet', 'neumann_neumann', or 'dirichlet_neumann'"
            )
        return wavenumbers

    def _calculate_mode_angular_frequencies(self) -> jnp.ndarray:
        return self.wave_speed * self.wavenumbers

    def _calculate_mode_shapes(self) -> jnp.ndarray:
        # Size of modes is (n_max_modes, n_gridpoints)
        if self.boundary_conditions == "dirichlet_dirichlet":
            modes = jnp.array(
                [
                    jnp.sin(self.wavenumbers[n] * self.grid)
                    for n in range(0, self.n_max_modes)
                ]
            )
        elif self.boundary_conditions == "neumann_neumann":
            modes = jnp.array(
                [
                    jnp.cos(self.wavenumbers[n] * self.grid)
                    for n in range(0, self.n_max_modes)
                ]
            )
        elif self.boundary_conditions == "dirichlet_neumann":
            modes = jnp.array(
                [
                    jnp.sin(self.wavenumbers[n] * self.grid)
                    for n in range(0, self.n_max_modes)
                ]
            )
        else:
            raise ValueError(
                "boundary_conditions must be either 'dirichlet_dirichlet', 'neumann_neumann', or 'dirichlet_neumann'"
            )
        return modes

    def _calculate_mode_coefficients(
        self,
        u0: jnp.ndarray = None,  # initial displacement (default: None)
        v0: jnp.ndarray = None,  # initial velocity (default: None)
    ):
        # check that each mode and initial conditions are the same size
        if self.modes.shape[1] != u0.shape[0]:
            raise ValueError(
                "modes and u0 must have the same number of grid points (modes.shape[1] != u0.shape[0])"
            )
        if self.modes.shape[1] != v0.shape[0]:
            raise ValueError(
                "modes and v0 must have the same number of grid points (modes.shape[1] != v0.shape[0])"
            )
        # calculate the coefficients of the sine/cosine series representing the initial conditions
        # We assume that the initial conditions can be indeed represented as a sine/cosine series
        coeffs_a = jnp.array(
            (2 / self.length) * integrate.trapezoid(self.modes * u0, self.grid)
        )
        coeffs_b = jnp.array(
            (2 / (self.length * self.omegas))
            * integrate.trapezoid(self.modes * v0, self.grid)
        )
        # Coorection to the 0 frequency mode for neumann_neumann boundary conditions,
        if self.boundary_conditions == "neumann_neumann":
            coeffs_a[0] /= 2.0
            coeffs_b[0] /= 2.0

        return (coeffs_a, coeffs_b)

    def create_initial_conditions(
        self,
        key: jnp.ndarray = None,  # random key for jax random number generator (default: None)
        type: str = "gaussian",  # type of initial condition, only gaussian implemented atm (default: "gaussian")
        x0: float = 0.5,  # location of the initial condition, relative to string length (default: 0.5)
        sigma: float = 0.1,  # width of the gaussian, relative to string length (default: 0.1)
        amplitude: float = 1,  # amplitude of the initial condition (default: 1)
    ) -> tuple[jnp.ndarray, jnp.array]:
        """This method creates the initial conditions, u0 and v0, for the simulation.
        Current implementation only supports plucks (v0=0) both gaussian and noise."""
        # Only gaussian pluck (v0=0) implemented atm
        # Depending on the type of boundary conditions, the initial condition needs to be adjusted
        # For dirichlet_dirichlet, the initial displacement and velocity need to be 0 at the end points

        # check that grid is provided
        if type == "gaussian":
            u0 = amplitude * jnp.exp(
                -((self.grid - x0 * self.length) ** 2)
                / (2 * (sigma * self.length) ** 2)
            )
            v0 = jnp.zeros(self.grid.shape)
        elif type == "noise":
            # Check that a key is provided
            if key is None:
                raise ValueError(
                    "For noise initial conditions, a key for the jax random number generator must be provided"
                )
            u0 = jax.random.uniform(key, shape=self.grid.shape, minval=-1, maxval=1)
            v0 = jnp.zeros(self.grid.shape)

        else:
            raise ValueError("type must be either 'gaussian' ")

        # Enforce boundary conditions
        if self.boundary_conditions == "dirichlet_dirichlet":
            u0 = u0.at[0].set(0.0)
            u0 = u0.at[-1].set(0.0)
            v0 = v0.at[0].set(0.0)
            v0 = v0.at[-1].set(0.0)
        elif self.boundary_conditions == "neumann_neumann":
            # Assert that for neumann_neumann boundary conditions, the initial velocity is 0 for the whole domain
            # this is not strictly necessary, but is good precaution until a safe way to set initial velocity in this case is implemented
            if not jnp.all(v0 == 0):
                raise ValueError(
                    "For neumann_neumann boundary conditions, the initial velocity must be 0 for the whole domain"
                )
        elif self.boundary_conditions == "dirichlet_neumann":
            u0 = u0.at[0].set(0.0)
            v0 = v0.at[0].set(0.0)

        return (u0, v0)

    def solve(
        self,
        u0: jnp.ndarray = None,  # initial displacement (default: None)
        v0: jnp.ndarray = None,  # initial velocity (default: None)
    ) -> tuple[jnp.ndarray, jnp.array, jnp.array]:
        # project initial conditions onto the modes
        coeffs_a, coeffs_b = self._calculate_mode_coefficients(u0, v0)

        @jax.jit
        def _solve_single_time(t, coeffs_a, coeffs_b):
            u_t = jnp.sum(
                (
                    coeffs_a[..., None] * jnp.cos(self.omegas * t)[..., None]
                    + coeffs_b[..., None] * jnp.sin(self.omegas * t)[..., None]
                )
                * self.modes,
                axis=0,
            )
            v_t = jnp.sum(
                (
                    -1
                    * coeffs_a[..., None]
                    * self.omegas[..., None]
                    * jnp.sin(self.omegas * t)[..., None]
                    + coeffs_b[..., None]
                    * self.omegas[..., None]
                    * jnp.cos(self.omegas * t)[..., None]
                )
                * self.modes,
                axis=0,
            )
            return u_t, v_t

        solve_fn_vmap = jax.vmap(_solve_single_time, in_axes=(0, None, None))
        u, v = solve_fn_vmap(self.timesteps, coeffs_a, coeffs_b)

        return (self.timesteps, u, v)
